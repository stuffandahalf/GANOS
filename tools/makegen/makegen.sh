#!/bin/sh

################################ makegen.sh help ###############################
# 
# This script reads parameters from the file ./make.mg and transforms them into
# a makefile suitable to build the project
#
# arguments: (None yet)
#
# -f				input parameter file 
# 
# -p				prefix to be prepended to any install targets
# 
# -t				toolchain file
# 
# -b				build type
# 
# -h				print help message
# 
################################################################################

################################# make.mg help #################################
# 
# common fields
# 
# 	TYPE			The type of application to be built. Can be one of the
#                   following:
# 					prog	- executable application
# 					lib		- application library
#					meta	- builds all sub-targets. see meta/SUBDIRS field
#                             for more
# 
# 	INCLUDE_DIRS	Directories to be searched for include headers
# 
# 	ARCH			The architecture for the target or subdirs
# 
# 	OS				The OS the target is designed to run on
# 
# 	EXE_FMT			The executable format for the target
# 
# prog fields
# 
# 	TARGET			the name of the executable to be built
# 
# 	SRCS			the list or pattern for all required source files
# 
# 	$ARCH_SRCS		optional source files only included if $ARCH matches
# 					the value of the ARCH field
# 
# 	INSTALL_DIR		when the install target of the makefile is run, install
# 					TARGET to $PREFIX/$INSTALL_DIR/
# 
# 	LINKER			optionally set what program to use for linker
# 
# lib fields
# 
# 	LIB_TYPE		type of the library, can be "shared" or "static"
# 
# 	TARGET			the name of the library to be build
#
# 	SRCS			the list of pattern for all required source files
# 
# 	$ARCH_SRCS		optional source files only include if $ARCH matches the
# 					value of the ARCH field
# 
# 	INSTALL_DIR		when the install target of the makefile is run, install
# 					TARGET TO $PREFIX/$INSTALL_DIR/
# 
# meta fields
#
# 	SUBDIRS			the list or pattern for all subdirs to be built by this
# 					makefile
# 
###############################################################################

################################ toolchain help ###############################
# 
# Fields that can be set globally using a toolchain file
# 
# 	ARCH			The architecture of the target machine. To be used, must
# 					be configured manually using ASFLAGS, CFLAGS, abd LDFLAGS
# 
# 	AS				Path to an assembler
# 
# 	CC				Path to a C compiler
# 
#	LD				Path to a linker
# 
# 	ASFLAGS			Flags to be passed to the assembler in every
# 					invocation
# 
# 	CFLAGS			Flags to be passed to the C compiler during
# 					compilation
# 
# 	LDFLAGS			Flags to be passed to the linker during the
# 					linking step
# 
# 	INCLUDE_DIRS	Directories to be searched for headers
# 
###############################################################################

set -e

DEBUG=true
# emits a debug message to stderr if $DEBUG=true
echo_debug()
{
	if [ "$DEBUG" = true ]; then
		echo "$@" 1>&2
	fi
}

# retrieves field $1 from $2
get_field()
{
	echo "$2" | \
		grep "^$1[[:space:]]*=[[:space:]]*" | \
		sed -n -e "s/^$1[[:space:]]*=[[:space:]]*//p"
}

# writes all arguments to $OUT_FILEss
emit()
{
	echo "$@" >> $OUT_FILE
}

fail()
{
	if [ ! -z "$@" ]; then
		echo ERROR: "$@" 1>&2
	fi
	if [ -e "$OUT_FILE" ]; then
		rm $OUT_FILE
	fi
	exit 1
}

# from https://stackoverflow.com/questions/3915040/bash-fish-command-to-print-absolute-path-to-a-filehttps://stackoverflow.com/questions/3915040/bash-fish-command-to-print-absolute-path-to-a-file
# $1 = a path to a file
realpath()
{
	echo "$(cd $(dirname $1); pwd -L)/$(basename $1)"
}

realpath2()
{
	echo "$(dirname $1)/$(basename $1)"
}

# lazily produces a path to $1 from $2
relpath()
{
	echo_debug "$1"
	echo_debug "$2"
	echo "$1" | \
		tr '/' '\$' | \
		sed -n -e "s/^$(echo \"$2\" | tr '/' '\$')//p" | \
		tr '\$' '/'
}

# $1 = source file
emit_compile()
{
	SRC_FILE=$1
	case $SRC_FILE in
	*.c)
		BASEDIR="$(dirname $SRC_FILE)"
		INCLUDES=`cat $SRC_FILE | \
			grep "^\s*#\s*include\s\+\".*\"" | \
			sed -n -e "s/^\s*#\s*include\s\+\"/$BASEDIR\//p" | \
			sed -n -e 's/\"\s*$//p' | \
			tr '\r\n' '\n' | tr '\n' ' '`
		echo_debug "Include files for $SRC_FILE"
		echo_debug "$INCLUDES"
		echo_debug ""
	
		emit "\$(BUILD_DIR)/$(echo $SRC_FILE | tr '/' '.').o: \$(BUILD_DIR)/.dirstamp $SRC_FILE $INCLUDES"
		emit "	+echo \"[COMPILE]	$(realpath $SRC_FILE)\" 1>&2"
		emit "	\$(CC) \$(CFLAGS) -c -o \$(BUILD_DIR)/$(echo $SRC_FILE | tr '/' '.').o $SRC_FILE"
		emit ""
		unset INCLUDES
		;;
	*.s)
		emit "\$(BUILD_DIR)/$(echo $SRC_FILE | tr '/' '.').o: \$(BUILD_DIR)/.dirstamp $SRC_FILE"
		emit "	+echo \"[ASSEMBLE]	$(realpath $SRC_FILE)\" 1>&2"
		emit "	\$(AS) \$(ASFLAGS) -o \$(BUILD_DIR)/$(echo $SRC_FILE | tr '/' '.').o $SRC_FILE"
		emit ""
		;;
	*)
		fail "$SRC_FILE has an unsupported file extension" 1>&2
		;;
	esac
}

write_common_header()
{
	emit "# This makefile was generated by makegen.sh on $(date)"
	emit ".POSIX:"
	emit ".SILENT:"
	emit ""
	emit "FILE=$TARGET"
	emit "BUILD_DIR=$(realpath2 \"$BUILD_DIR\")"
	emit "DIST_DIR=$(realpath2 \"$PREFIX$INSTALL_DIR\")"
	emit "TARGET=\$(BUILD_DIR)/\$(FILE)"
	emit ""
	if [ ! -z "$ARCH" ]; then
		emit "ARCH=$ARCH"
	fi
	if [ ! -z "$OS" ]; then
		emit "OS=$OS"
	fi
	if [ ! -z "$EXE_FMT" ]; then
		emit "EXE_FMT=$EXE_FMT"
	fi
	emit "ASFLAGS=$ASFLAGS"
	emit "CFLAGS=$CFLAGS"
	emit "LDFLAGS=$LDFLAGS"
	emit ""
	if [ ! -z "$AS" ]; then
		emit "AS=\"$AS\""
	fi
	if [ ! -z "$CC" ]; then
		emit "CC=\"$CC\""
	fi
	if [ ! -z "$LD" ]; then
		emit "LD=\"$LD\""
	fi
	emit ""
	emit "all: \$(TARGET)"
}

# TARGET		target file
# SRCS			input source files, C, asm
# LINKER		linker used to link the object files
# BUILD_DIR		where to put intermediate object files
# PREFIX		base install directory
# INSTALL_DIR	install directory relative to $PREFIX
write_prog()
{
	write_common_header
	emit ""
	emit "install: \$(DIST_DIR)/\$(FILE)"
	emit ""
	emit "clean:"
	emit "	+echo \"[DELETE]	\$(BUILD_DIR)\" 1>&2"
	emit "	rm -rf \$(BUILD_DIR)"
	emit ""
	emit ""
	emit "\$(BUILD_DIR)/.dirstamp:"
	emit "	+echo \"[MKDIR]		\$(BUILD_DIR)\"  1>&2"
	emit "	mkdir -p \$(BUILD_DIR) && touch \$(BUILD_DIR)/.dirstamp"
	emit ""
	emit "\$(DIST_DIR)/.dirstamp:"
	emit "	+echo \"[MKDIR]		\$(DIST_DIR)\" 1>&2"
	emit "	mkdir -p \$(DIST_DIR) && touch \$(DIST_DIR)/.dirstamp"
	emit ""
	emit ""
	emit "\$(TARGET): \$(BUILD_DIR)/.dirstamp $OBJS"
	#emit "	$LINKER \$(CFLAGS) \$(LDFLAGS) -o \$(TARGET) $OBJS"
	emit "	+echo \"[LINK]		\$(TARGET)\" 1>&2"
	emit "	$LINKER \$(LDFLAGS) -o \$(TARGET) $OBJS"
	emit ""
	for SRC_FILE in $SRCS; do
		emit_compile $SRC_FILE
	done
	emit "\$(DIST_DIR)/\$(FILE): \$(DIST_DIR)/.dirstamp \$(TARGET)"
	emit "	+echo \"[INSTALL]	\$(DIST_DIR)/\$(FILE)\" 1>&2"
	emit "	cp \$(TARGET) \$(DIST_DIR)/"
	emit ""
}

# TARGET		target library
# OBJS			intermediate objects
# SRCS			input source files
# BUILD_DIR		where to store intermediate objects
# PREFIX		base install directory
# INSTALL_DIR	install directory relative to $PREFIX
write_lib()
{
	write_common_header
	emit ""
	emit "install: \$(DIST_DIR)/\$(FILE)"
	emit ""
	emit "clean:"
	emit "	rm -rf \$(BUILD_DIR)"
	emit ""
	emit ""
	emit "\$(BUILD_DIR)/.dirstamp:"
	emit "	mkdir -p \$(BUILD_DIR) && touch \$(BUILD_DIR)/.dirstamp"
	emit ""
	emit "\$(DIST_DIR)/.dirstamp:"
	emit "	mkdir -p \$(DIST_DIR) && touch \$(DIST_DIR)/.dirstamp"
	emit ""
	emit ""
	emit "\$(TARGET): \$(BUILD_DIR)/.dirstamp $OBJS"
	#emit "	$LINKER \$(CFLAGS) \$(LDFLAGS) -o \$(TARGET) $OBJS"
	emit "	$LINKER \$(LDFLAGS) -o \$(TARGET) $OBJS"
	emit ""
	for SRC_FILE in $SRCS; do
		emit_compile $SRC_FILE
	done
	emit "\$(DIST_DIR)/\$(FILE): \$(DIST_DIR)/.dirstamp \$(TARGET)"
	emit "	cp \$(TARGET) \$(DIST_DIR)/"
	emit ""
}

write_meta()
{
	emit "# This makefile was generated by makegen.sh on `date`"
	emit ".POSIX:"
	emit ""
	emit "all: $SUBDIR_TARGETS"
	emit ""
	for SUBDIR in $SUBDIRS; do
		emit "$SUBDIR.dir: $SUBDIR"
		emit "	cd $SUBDIR && \$(MAKE) all"
		emit ""
	done
	emit "install: $SUBDIR_TARGETS"
	for SUBDIR in $SUBDIRS; do
		emit "	cd $SUBDIR && \$(MAKE) install"
	done
	emit ""
	emit "clean:"
	for SUBDIR in $SUBDIRS; do
		emit "	cd $SUBDIR && \$(MAKE) clean"
	done
	emit ""
}

if [ -z "$PROJ_ROOT" ]; then
	export PROJ_ROOT="$PWD"
fi
if [ -z "$IN_FILE" ]; then
	export IN_FILE=make.mg
fi
if [ -z "$OUT_FILE" ]; then
	export OUT_FILE=Makefile
fi
if [ -z "$BUILD_DIR" ]; then
	export BUILD_DIR="$PROJ_ROOT/build"
else
	export BUILD_DIR="$PROJ_ROOT/build/$(relpath \"$PWD\" \"$PROJ_ROOT\")"
fi
echo_debug "\$BUILD_DIR = \"$BUILD_DIR\""
if [ -z $BUILD_TYPE ]; then
	export BUILD_TYPE=release
fi
if [ ! -z "$PREFIX" ]; then
	export PREFIX=`realpath "$PREFIX"`
fi
if [ -z "$MAKEGEN" ]; then
	export MAKEGEN=`realpath "$0"`
fi

while getopts f:b:t:p:h flag; do
	case $flag in
	f)
		echo_debug "Flag -f $OPTARG"
		IN_FILE=$OPTARG
		;;
	b)
		echo_debug "Flag -b $OPTARG"
		BUILD_TYPE="$OPTARG"
		# Build type
		;;
	t)
		echo_debug "Flag -t $OPTARG"
		# Toolchain file
		TOOLCHAIN=`cat "$OPTARG"`
		if [ -z "$AS" ]; then
			AS="`get_field AS \"$TOOLCHAIN\"`"
			if ! command -v "$AS" &> /dev/null; then
				AS="$(realpath $(dirname $OPTARG)/$AS)"
			fi
			export AS
		fi
		if [ -z "$CC" ]; then
			CC="`get_field CC \"$TOOLCHAIN\"`"
			if ! command -v "$CC" &> /dev/null; then
				CC="$(realpath $(dirname $OPTARG)/$CC)"
			fi
			export CC
		fi
		if [ -z "$LD" ]; then
			LD="`get_field LD \"$TOOLCHAIN\"`"
			if ! command -v "$LD" &> /dev/null; then
				LD="$(realpath $(dirname $OPTARG)/$LD)"
			fi
			export LD
		fi
		if [ -z "$ARCH" ]; then
			export ARCH="`get_field ARCH \"$TOOLCHAIN\"`"
		fi
		if [ -z "$OS" ]; then
			export OS="`get_field OS \"$TOOLCHAIN\"`"
		fi
		if [ -z "$EXE_FMT" ]; then
			export EXE_FMT="`get_field EXE_FMT \"$TOOLCHAIN\"`"
		fi
		export ASFLAGS="$ASFLAGS `get_field ASFLAGS \"$TOOLCHAIN\"`"
		export CFLAGS="$CFLAGS `get_field CFLAGS \"$TOOLCHAIN\"`"
		INCLUDE_DIRS="`get_field INCLUDE_DIRS \"$TOOLCHAIN\"`"
		INCLUDE_DIR_PREFIX="$(dirname $OPTARG)"
		for DIR in "$INCLUDE_DIRS"; do
			export CFLAGS="$CFLAGS -I\"$(realpath $INCLUDE_DIR_PREFIX/$DIR)\""
		done
		unset INCLUDE_DIR_PREFIX
		export LDFLAGS="$LDFLAGS `get_field LDFLAGS \"$TOOLCHAIN\"`"
		
		echo_debug "TOOLCHAIN VALUES START"
		echo_debug "	\$AS=$AS"
		echo_debug "	\$CC=$CC"
		echo_debug "	\$LD=$LD"
		echo_debug "	\$ASFLAGS=$ASFLAGS"
		echo_debug "	\$CFLAGS=$CFLAGS"
		echo_debug "	\$LDFLAGS=$LDFLAGS"
		echo_debug "	\$ARCH=$ARCH"
		echo_debug "	\$OS=$OS"
		echo_debug "	\$EXE_FMT=$EXE_FMT"
		echo_debug "TOOLCHAIN VALUES END"
		;;
	p)
		export PREFIX="$(realpath \"$OPTARG\")"
		;;
	h)
		echo_debug "Flag -h"
		print_help
		exit 0
		;;
	*)
		echo "Unrecognized flag \"$flag\"" 1>&2
		echo ""
		print_help
		exit 1
		;;
	esac
done

FIELDS="$(cat "$IN_FILE")"
MG_TYPE="`get_field TYPE \"$FIELDS\"`"
ASFLAGS="$ASFLAGS `get_field ASFLAGS \"$FIELDS\"`"
CFLAGS="$CFLAGS `get_field CFLAGS \"$FIELDS\"`"
LDFLAGS="$LDFLAGS `get_field LDFLAGS \"$FIELDS\"`"
NEW_ARCH="`get_field ARCH \"$FIELDS\"`"
if [ ! -z "$NEW_ARCH" ]; then
	export ARCH="$NEW_ARCH"
fi
unset NEW_ARCH
NEW_OS="`get_field OS \"$FIELDS\"`"
if [ ! -z "$NEW_OS" ]; then
	export OS="$NEW_OS"
fi
unset NEW_OS
NEW_EXE_FMT="`get_field EXE_FMT \"$FIELDS\"`"
if [ ! -z "$NEW_EXE_FMT" ]; then
	export EXE_FMT="$NEW_EXE_FMT"
fi
unset NEW_EXE_FMT

case "$BUILD_TYPE" in
debug)
	echo_debug "Build type set to \"$BUILD_TYPE\""
	;;
release)
	echo_debug "Build_type set to \"$BUILD_TYPE\""
	CFLAGS="-O2 -DNDEBUG $CFLAGS"
	;;
*)
	fail "Build type \"$BUILD_TYPE\" is unrecognized"
	;;
esac

if [ -e $OUT_FILE ]; then
	rm $OUT_FILE
fi
touch $OUT_FILE

echo_debug "Constructing $(realpath $OUT_FILE)"
echo_debug "$FIELDS"

case $MG_TYPE in
meta)
	SUBDIRS="`get_field SUBDIRS "$FIELDS"`"
	SUBDIR_TARGETS=""
	for SUBDIR in $SUBDIRS; do
		SUBDIR_TARGETS="$SUBDIR_TARGETS $SUBDIR.dir"
	done
	
	write_meta
	for SUBDIR in $SUBDIRS; do
		RETURN_DIR="$(echo $PWD)"
		echo "ENTERING $SUBDIR"
		cd "$SUBDIR" && "$MAKEGEN" && cd "$RETURN_DIR"
		echo "EXITING $SUBDIR"
		unset RETURN_DIR
	done
	;;
prog)
	TARGET=`get_field TARGET "$FIELDS"`
	SRCS="`get_field SRCS \"$FIELDS\"`"
	if [ ! -z "$ARCH" ]; then
		SRCS="$SRCS `get_field ${ARCH}_SRCS \"$FIELDS\"`"
	fi
	SRCS=$(echo $SRCS)
	INSTALL_DIR="`get_field INSTALL_DIR "$FIELDS"`"
	LINKER="`get_field LINKER "$FIELDS"`"
	if [ -z "$LINKER" ]; then
		#LINKER="\$(CC)"
		LINKER="\$(LD)"
	fi

	echo_debug "\$TARGET has value '$TARGET'"
	echo_debug "\$SRCS has value '$SRCS'"

	OBJS=
	for SRC_FILE in $SRCS; do
		OBJS="$OBJS \$(BUILD_DIR)/$(echo $SRC_FILE | tr '/' '.').o"
	done

	echo_debug "\$PREFIX = $PREFIX"
	if [ "{$PREFIX#${PREFIX%?}}" != / ]; then
		PREFIX="$PREFIX/"
	fi
	if [ "{$INSTALL_DIR#${INSTALL_DIR%?}}" != / ]; then
		INSTALL_DIR="$INSTALL_DIR/"
	fi

	write_prog
	;;
lib)
	LIB_TYPE="`get_field LIB_TYPE \"$FIELDS\"`"
	TARGET="`get_field TARGET \"$FIELDS\"`"
	SRCS="`get_field SRCS \"$FIELDS\"`"
	if [ ! -z "$ARCH" ]; then
		SRCS="$SRCS `get_field ${ARCH}_SRCS \"$FIELDS\"`"
	fi
	SRCS="$(echo $SRCS)"
	INSTALL_DIR="`get_field INSTALL_DIR \"$FIELDS\"`"
	LINKER="`get_field LINKER \"$FIELDS\"`"
	if [ -z "$LINKER" ]; then
		LINKER="\$(CC)"
	fi
	
	case $LIB_TYPE in
	static)
		LDFLAGS="$LDFLAGS -static"
		TARGET="lib$TARGET.a"
		;;
	shared)
		CFLAGS="$CFLAGS -fpic"
		LDFLAGS="$LDFLAGS -shared"
		TARGET="lib$TARGET.so"
		;;
	*)
		fail "Invalid library type $LIB_TYPE specified"
		;;
	esac
	
	OBJS=
	for SRC_FILE in $SRCS; do
		OBJS="$OBJS \$(BUILD_DIR)/$(echo $SRC_FILE | tr '/' '.').o"
	done
	
	if [ "{$PREFIX#${PREFIX%?}}" != / ]; then
		PREFIX="$PREFIX/"
	fi
	if [ "{$INSTALL_DIR#${INSTALL_DIR%?}}" != / ]; then
		INSTALL_DIR="$INSTALL_DIR/"
	fi
	
	write_lib
	;;
*)
	fail "$(realpath $IN_FILE): Invalid TYPE field or TYPE field missing"
	;;
esac

