#!/bin/sh

################################ makegen.sh help ###############################
# 
# This script reads parameters from the file ./make.mg and transforms them into
# a makefile suitable to build the project
#
# arguments: (None yet)
#
# -f				input parameter file 
# 
# -p				prefix to be prepended to any install targets
# 
# -c				c compiler options
#
# -s				as options
# 
# -+				c++ compiler options
# 
# -t				build type
# 
# -h				print help message
# 
################################################################################

################################# make.mg help #################################
# 
# common fields
# 	TYPE			The type of application to be built. Can be one of the following:
# 					prog	- executable application
# 					lib		- application library
#					meta	- builds all sub-targets. see meta/SUBDIRS field for more
# 
# prog fields
# 	TARGET			the name of the executable to be built
# 
# 	SRCS			the list or pattern for all required source files
# 
# 	INSTALL_DIR		when the install target of the makefile is run, install
# 					TARGET to $PREFIX/$INSTALL_DIR/
# 
# 	LINKER			optionally set what program to use for linker
# 
# lib fields
# 	TARGET			the name of the library to be build
#
# 	SRCS			the list of pattern for all required source files
# 
# 	INSTALL_DIR		when the install target of the makefile is run, install
# 					TARGET TO $PREFIX/$INSTALL_DIR/
# 
# meta fieldss
#
# 	SUBDIRS			the list or pattern for all subdirs to be built by this
# 					makefile
# 
################################################################################

set -e

DEBUG=true
# emits a debug message to stderr if $DEBUG=true
echo_debug()
{
	if [ "$DEBUG" = true ]; then
		echo $@ 1>&2
	fi
}

# retrieves field $1 from $FIELDS
get_field()
{
	echo "$FIELDS" | \
		grep "^$1[[:space:]]*=[[:space:]]*" | \
		sed -n -e "s/^$1[[:space:]]*=[[:space:]]*//p"
}

# writes all arguments to $OUT_FILEss
emit()
{
	echo "$@" >> $OUT_FILE
}

# from https://stackoverflow.com/questions/3915040/bash-fish-command-to-print-absolute-path-to-a-filehttps://stackoverflow.com/questions/3915040/bash-fish-command-to-print-absolute-path-to-a-file
# $1 = a path to a file
realpath()
{
	echo "$(cd "$(dirname "$1")"; pwd -P)/$(basename "$1")"
}

relpath()
{
	echo_debug "$1"
	echo_debug "$2"
	echo "$1" | tr '/' '\$' | sed -n -e "s/^`echo \"$2\" | tr '/' '\$'`//p" | tr '\$' '/'
}

# $1 = source file
emit_compile()
{
	SRC_FILE=$1
	case $SRC_FILE in
	*.c)
		BASEDIR=`dirname $SRC_FILE`
		INCLUDES=`cat $SRC_FILE | \
			grep "^\s*#\s*include\s\+\".*\"" | \
			sed -n -e "s/^\s*#\s*include\s\+\"/$BASEDIR\//p" | \
			sed -n -e 's/\"\s*$//p' | \
			tr '\r\n' '\n' | tr '\n' ' '`
		echo_debug "Include files for $SRC_FILE"
		echo_debug "$INCLUDES"
		echo_debug ""
	
		emit "$BUILD_DIR/`echo $SRC_FILE | tr '/' '.'`.o: $BUILD_DIR $SRC_FILE $INCLUDES"
		emit "	\$(CC) \$(CFLAGS) -c -o $BUILD_DIR/`echo $SRC_FILE | tr '/' '.'`.o $SRC_FILE"
		emit ""
		unset INCLUDES
		;;
	*.s)
		emit "$BUILD_DIR/`echo $SRC_FILE | tr '/' '.'`.o: $BUILD_DIR $SRC_FILE"
		emit "	\$(AS) \$(ASFLAGS) -o $BUILD_DIR/`echo $SRC_FILE | tr '/' '.'`.o $SRC_FILE"
		;;
	*)
		echo "ERROR: $SRC_FILE has an unsupported file extension" 1>&2
		rm "$OUT_FILE"
		exit 1
		;;
	esac
}

# TARGET		target file
# SRCS			input source files, C, asm
# LINKER		linker used to link the object files
# BUILD_DIR		where to put intermediate object files
# PREFIX		base install directory
# INSTALL_DIR	install directory relative to $PREFIX
write_prog()
{
	emit "# This makefile was generated by makegen.sh on `date`"
	emit ".POSIX:"
	emit ""
	emit "TARGET=$BUILD_DIR/$TARGET"
	emit ""
	emit "all: \$(TARGET)"
	emit "	"
	emit ""
	emit "\$(TARGET): '$BUILD_DIR' $OBJS"
	emit "	$LINKER \$(CFLAGS) \$(LDFLAGS) -o \$(TARGET) $OBJS"
	emit ""
	for SRC_FILE in $SRCS; do
		emit_compile $SRC_FILE
	done
	emit "'$BUILD_DIR':"
	emit "	mkdir -p '$BUILD_DIR'"
	emit ""
	emit "install: '$PREFIX$INSTALL_DIR' \$(TARGET)"
	emit "	cp \$(TARGET) '$PREFIX$INSTALL_DIR'"
	emit ""
	emit "'$PREFIX$INSTALL_DIR':"
	emit "	mkdir -p '$PREFIX$INSTALL_DIR'"
	emit ""
	emit "clean:"
	emit "	rm -rf $BUILD_DIR"
	emit ""
	emit ""
}

# TARGET		target library
# OBJS			intermediate objects
# SRCS			input source files
# BUILD_DIR		where to store intermediate objects
# PREFIX		base install directory
# INSTALL_DIR	install directory relative to $PREFIX
write_lib()
{
	emit "# This makefile was generated by makegen.sh on `date`"
	emit ".POSIX:"
	emit ""
	emit "TARGET=$TARGET"
	emit ""
	emit "all: \$(TARGET)"
	emit ""
	emit "\$(TARGET): $OBJS"
	emit "	"
	emit ""
	for SRC_FILE in $SRCS; do
		emit_compile $SRC_FILE
	done
	emit "$BUILD_DIR:"
	emit "	mkdir -p $BUILD_DIR"
	emit ""
	emit "install: $PREFIX$INSTALL_DIR \$(TARGET)"
	emit "	cp \$(TARGET) $PREFIX$INSTALL_DIR"
	emit ""
	emit "$PREFIX$INSTALL_DIR:"
	emit "	mkdir -p $PREFIX$INSTALL_DIR"
	emit ""
	emit "clean:"
	emit "	rm -rf $BUILD_DIR"
	emit ""
	emit ""
}

write_meta()
{
	emit "# This makefile was generated by makegen.sh on `date`"
	emit ".POSIX:"
	emit ""
	emit "all: $SUBDIR_TARGETS"
	emit ""
	for SUBDIR in $SUBDIRS; do
		emit "$SUBDIR.dir: $SUBDIR"
		emit "	cd $SUBDIR && \$(MAKE) all"
		emit ""
	done
	emit "install: $SUBDIR_TARGETS"
	for SUBDIR in $SUBDIRS; do
		emit "	cd $SUBDIR && \$(MAKE) install"
	done
	emit ""
	emit "clean:"
	for SUBDIR in $SUBDIRS; do
		emit "	cd $SUBDIR && \$(MAKE) clean"
	done
	emit ""
}

if [ -z "$PROJ_ROOT" ]; then
	export PROJ_ROOT="$PWD"
fi
if [ -z "$IN_FILE" ]; then
	export IN_FILE=make.mg
fi
if [ -z "$OUT_FILE" ]; then
	export OUT_FILE=Makefile
fi
if [ -z "$BUILD_DIR" ]; then
	export BUILD_DIR="$PROJ_ROOT/build"
else
	export BUILD_DIR="$PROJ_ROOT/build/`relpath \"$PWD\" \"$PROJ_ROOT\"`"
fi
echo_debug "\$BUILD_DIR = \"$BUILD_DIR\""
if [ -z $BUILD_TYPE ]; then
	export BUILD_TYPE=release
fi
if [ -z $BUILD_TYPE ]; then
	export CFLAGS="-O3 -DNDEBUG"
fi
if [ ! -z "$PREFIX" ]; then
	export PREFIX=`realpath "$PREFIX"`
fi
if [ -z "$MAKEGEN" ]; then
	export MAKEGEN=`realpath "$0"`
fi


while getopts f:s:c:+:t:p:h flag; do
	case $flag in
	f)
		echo_debug "Flag -f $OPTARG"
		IN_FILE=$OPTARG
		;;
	s)
		echo_debug "Flag -s $OPTARG"
		;;
	c)
		echo_debug "Flag -c $OPTARG"
		;;
	+)
		echo_debug "Flag -+ $OPTARG"
		;;
	t)
		echo_debug "Flag -t $OPTARG"
		case $OPTARG in
		debug)
			echo_debug "Build type set to \"$OPTARG\""
			;;
		release)
			echo_debug "Build_type set to \"$OPTARG\""
			;;
		*)
			echo "Build type \"$OPTARG\" is unrecognized" 1>&2
			;;
		esac
		;;
	p)
		export PREFIX=`realpath "$OPTARG"`
		;;
	h)
		echo_debug "Flag -h"
		print_help
		exit 0
		;;
	*)
		echo "Unrecognized flag \"$flag\"" 1>&2
		echo ""
		print_help
		exit 1
		;;
	esac
done

FIELDS=`cat "$IN_FILE"`

MG_TYPE=`get_field TYPE`

if [ -e $OUT_FILE ]; then
	rm $OUT_FILE
fi
touch $OUT_FILE

echo_debug "Constructing `realpath $OUT_FILE`"
echo_debug "$FIELDS"

case $MG_TYPE in
meta)
	SUBDIRS=`get_field SUBDIRS`
	SUBDIR_TARGETS=""
	for SUBDIR in $SUBDIRS; do
		SUBDIR_TARGETS="$SUBDIR_TARGETS $SUBDIR.dir"
	done
	
	write_meta
	for SUBDIR in $SUBDIRS; do
		RETURN_DIR=`echo $PWD`
		cd "$SUBDIR" && "$MAKEGEN" && cd "$RETURN_DIR"
		unset RETURN_DIR
	done
	;;
prog)
	TARGET=`get_field TARGET`
	SRCS=`get_field SRCS`
	SRCS=`echo $SRCS`
	INSTALL_DIR=`get_field INSTALL_DIR`
	LINKER=`get_field LINKER`
	if [ -z "$LINKER" ]; then
		LINKER="\$(CC)"
	fi

	echo_debug "\$TARGET has value '$TARGET'"
	echo_debug "\$SRCS has value '$SRCS'"

	OBJS=
	for SRC_FILE in $SRCS; do
		OBJS="$OBJS $BUILD_DIR/`echo $SRC_FILE | tr '/' '.'`.o"
	done

	echo_debug "\$PREFIX = $PREFIX"
	if [ "{$PREFIX#${PREFIX%?}}" != / ]; then
		PREFIX="$PREFIX/"
	fi
	if [ "{$INSTALL_DIR#${INSTALL_DIR%?}}" != / ]; then
		INSTALL_DIR="$INSTALL_DIR/"
	fi

	write_prog
	;;
lib)
	TARGET=`get_field TARGET`
	
	write_lib
	;;
*)
	echo "`realpath $IN_FILE`: Invalid TYPE field or TYPE field missing" 1>&2
	;;
esac

