#!/bin/sh

################################ makegen.sh help ###############################
# 
# This script reads parameters from the file ./make.mg and transforms them into
# a makefile suitable to build the project
#
# arguments: (None yet)
#
# -f				input parameter file 
# 
# -p				prefix to be prepended to any install targets
# 
# -c				c compiler options
#
# -s				as options
# 
# -+				c++ compiler options
# 
# -t				build type
# 
# -h				print help message
# 
################################################################################

################################# make.mg help #################################
# 
# common fields
# 
# 	TYPE			The type of application to be built. Can be one of the
#                   following:
# 					prog	- executable application
# 					lib		- application library
#					meta	- builds all sub-targets. see meta/SUBDIRS field
#                             for more
# 
# prog fields
# 
# 	TARGET			the name of the executable to be built
# 
# 	SRCS			the list or pattern for all required source files
# 
# 	INSTALL_DIR		when the install target of the makefile is run, install
# 					TARGET to $PREFIX/$INSTALL_DIR/
# 
# 	LINKER			optionally set what program to use for linker
# 
# lib fields
# 
# 	LIB_TYPE		type of the library, can be "shared" or "static"
# 
# 	TARGET			the name of the library to be build
#
# 	SRCS			the list of pattern for all required source files
# 
# 	INSTALL_DIR		when the install target of the makefile is run, install
# 					TARGET TO $PREFIX/$INSTALL_DIR/
# 
# meta fields
#
# 	SUBDIRS			the list or pattern for all subdirs to be built by this
# 					makefile
# 
################################################################################

set -e

DEBUG=true
# emits a debug message to stderr if $DEBUG=true
echo_debug()
{
	if [ "$DEBUG" = true ]; then
		echo $@ 1>&2
	fi
}

# retrieves field $1 from $FIELDS
get_field()
{
	echo "$FIELDS" | \
		grep "^$1[[:space:]]*=[[:space:]]*" | \
		sed -n -e "s/^$1[[:space:]]*=[[:space:]]*//p"
}

# writes all arguments to $OUT_FILEss
emit()
{
	echo "$@" >> $OUT_FILE
}

fail()
{
	if [ ! -z "$@" ]; then
		echo ERROR: "$@" 1>&2
	fi
	if [ -e "$OUT_FILE" ]; then
		rm $OUT_FILE
	fi
	exit 1
}

# from https://stackoverflow.com/questions/3915040/bash-fish-command-to-print-absolute-path-to-a-filehttps://stackoverflow.com/questions/3915040/bash-fish-command-to-print-absolute-path-to-a-file
# $1 = a path to a file
realpath()
{
	echo "$(cd "$(dirname "$1")"; pwd -L)/$(basename "$1")"
}

realpath2()
{
	echo "`dirname \"$1\"`/`basename \"$1\"`"
}

# lazily produces a path to $1 from $2
relpath()
{
	echo_debug "$1"
	echo_debug "$2"
	echo "$1" | \
		tr '/' '\$' | \
		sed -n -e "s/^`echo \"$2\" | tr '/' '\$'`//p" | \
		tr '\$' '/'
}

# $1 = source file
emit_compile()
{
	SRC_FILE=$1
	case $SRC_FILE in
	*.c)
		BASEDIR=`dirname $SRC_FILE`
		INCLUDES=`cat $SRC_FILE | \
			grep "^\s*#\s*include\s\+\".*\"" | \
			sed -n -e "s/^\s*#\s*include\s\+\"/$BASEDIR\//p" | \
			sed -n -e 's/\"\s*$//p' | \
			tr '\r\n' '\n' | tr '\n' ' '`
		echo_debug "Include files for $SRC_FILE"
		echo_debug "$INCLUDES"
		echo_debug ""
	
		emit "\$(BUILD_DIR)/`echo $SRC_FILE | tr '/' '.'`.o: \$(BUILD_DIR)/.dirstamp $SRC_FILE $INCLUDES"
		emit "	\$(CC) \$(CFLAGS) -c -o \$(BUILD_DIR)/`echo $SRC_FILE | tr '/' '.'`.o $SRC_FILE"
		emit ""
		unset INCLUDES
		;;
	*.s)
		emit "\$(BUILD_DIR)/`echo $SRC_FILE | tr '/' '.'`.o: \$(BUILD_DIR)/.dirstamp $SRC_FILE"
		emit "	\$(AS) \$(ASFLAGS) -o \$(BUILD_DIR)/`echo $SRC_FILE | tr '/' '.'`.o $SRC_FILE"
		emit ""
		;;
	*)
		fail "$SRC_FILE has an unsupported file extension" 1>&2
		;;
	esac
}

# TARGET		target file
# SRCS			input source files, C, asm
# LINKER		linker used to link the object files
# BUILD_DIR		where to put intermediate object files
# PREFIX		base install directory
# INSTALL_DIR	install directory relative to $PREFIX
write_prog()
{
	emit "# This makefile was generated by makegen.sh on `date`"
	emit ".POSIX:"
	emit ""
	emit "PROG=$TARGET"
	emit "BUILD_DIR=`realpath2 \"$BUILD_DIR\"`"
	emit "DIST_DIR=`realpath2 \"$PREFIX$INSTALL_DIR\"`"
	emit "TARGET=\$(BUILD_DIR)/\$(PROG)"
	emit ""
	emit "ASFLAGS=$ASFLAGS"
	emit "CFLAGS=$FLAGS"
	emit "LDFLAGS=$LDFLAGS"
	emit ""
	emit "all: \$(TARGET)"
	emit ""
	emit "install: \$(DIST_DIR)/\$(PROG)"
	emit ""
	emit "clean:"
	emit "	rm -rf \$(BUILD_DIR)"
	emit ""
	emit ""
	emit "\$(BUILD_DIR)/.dirstamp:"
	emit "	mkdir -p \$(BUILD_DIR) && touch \$(BUILD_DIR)/.dirstamp"
	emit ""
	emit "\$(DIST_DIR)/.dirstamp:"
	emit "	mkdir -p \$(DIST_DIR) && touch \$(DIST_DIR)/.dirstamp"
	emit ""
	emit ""
	emit "\$(TARGET): \$(BUILD_DIR)/.dirstamp $OBJS"
	emit "	$LINKER \$(CFLAGS) \$(LDFLAGS) -o \$(TARGET) $OBJS"
	emit ""
	for SRC_FILE in $SRCS; do
		emit_compile $SRC_FILE
	done
	emit "\$(DIST_DIR)/\$(PROG): \$(DIST_DIR)/.dirstamp \$(TARGET)"
	emit "	cp \$(TARGET) \$(DIST_DIR)/"
	emit ""
}

# TARGET		target library
# OBJS			intermediate objects
# SRCS			input source files
# BUILD_DIR		where to store intermediate objects
# PREFIX		base install directory
# INSTALL_DIR	install directory relative to $PREFIX
write_lib()
{
	emit "# This makefile was generated by makegen.sh on `date`"
	emit ".POSIX:"
	emit ""
	emit "LIB=$TARGET"
	emit "BUILD_DIR=`realpath2 \"$BUILD_DIR\"`"
	emit "DIST_DIR=`realpath2 \"$PREFIX$INSTALL_DIR\"`"
	emit "TARGET=\$(BUILD_DIR)/\$(LIB)"
	emit ""
	emit "CFLAGS=$CFLAGS"
	emit "LDFLAGS=$LDFLAGS"
	emit ""
	emit "all: \$(TARGET)"
	emit ""
	emit "install: \$(DIST_DIR)/\$(LIB)"
	emit ""
	emit "clean:"
	emit "	rm -rf \$(BUILD_DIR)"
	emit ""
	emit ""
	emit "\$(BUILD_DIR)/.dirstamp:"
	emit "	mkdir -p \$(BUILD_DIR) && touch \$(BUILD_DIR)/.dirstamp"
	emit ""
	emit "\$(DIST_DIR)/.dirstamp:"
	emit "	mkdir -p \$(DIST_DIR) && touch \$(DIST_DIR)/.dirstamp"
	emit ""
	emit ""
	emit "\$(TARGET): \$(BUILD_DIR)/.dirstamp $OBJS"
	emit "	$LINKER \$(CFLAGS) \$(LDFLAGS) -o \$(TARGET) $OBJS"
	emit ""
	for SRC_FILE in $SRCS; do
		emit_compile $SRC_FILE
	done
	emit "\$(DIST_DIR)/\$(LIB): \$(DIST_DIR)/.dirstamp \$(TARGET)"
	emit "	cp \$(TARGET) \$(DIST_DIR)/"
	emit ""
}

write_meta()
{
	emit "# This makefile was generated by makegen.sh on `date`"
	emit ".POSIX:"
	emit ""
	emit "all: $SUBDIR_TARGETS"
	emit ""
	for SUBDIR in $SUBDIRS; do
		emit "$SUBDIR.dir: $SUBDIR"
		emit "	cd $SUBDIR && \$(MAKE) all"
		emit ""
	done
	emit "install: $SUBDIR_TARGETS"
	for SUBDIR in $SUBDIRS; do
		emit "	cd $SUBDIR && \$(MAKE) install"
	done
	emit ""
	emit "clean:"
	for SUBDIR in $SUBDIRS; do
		emit "	cd $SUBDIR && \$(MAKE) clean"
	done
	emit ""
}

if [ -z "$PROJ_ROOT" ]; then
	export PROJ_ROOT="$PWD"
fi
if [ -z "$IN_FILE" ]; then
	export IN_FILE=make.mg
fi
if [ -z "$OUT_FILE" ]; then
	export OUT_FILE=Makefile
fi
if [ -z "$BUILD_DIR" ]; then
	export BUILD_DIR="$PROJ_ROOT/build"
else
	export BUILD_DIR="$PROJ_ROOT/build/`relpath \"$PWD\" \"$PROJ_ROOT\"`"
fi
echo_debug "\$BUILD_DIR = \"$BUILD_DIR\""
if [ -z $BUILD_TYPE ]; then
	export BUILD_TYPE=release
fi
if [ ! -z "$PREFIX" ]; then
	export PREFIX=`realpath "$PREFIX"`
fi
if [ -z "$MAKEGEN" ]; then
	export MAKEGEN=`realpath "$0"`
fi

while getopts f:s:c:+:t:p:h flag; do
	case $flag in
	f)
		echo_debug "Flag -f $OPTARG"
		IN_FILE=$OPTARG
		;;
	s)
		echo_debug "Flag -s $OPTARG"
		;;
	c)
		echo_debug "Flag -c $OPTARG"
		;;
	+)
		echo_debug "Flag -+ $OPTARG"
		;;
	t)
		echo_debug "Flag -t $OPTARG"
		BUILD_TYPE="$OPTARG"
		;;
	p)
		export PREFIX=`realpath "$OPTARG"`
		;;
	h)
		echo_debug "Flag -h"
		print_help
		exit 0
		;;
	*)
		echo "Unrecognized flag \"$flag\"" 1>&2
		echo ""
		print_help
		exit 1
		;;
	esac
done

FIELDS=`cat "$IN_FILE"`
MG_TYPE=`get_field TYPE`
ASFLAGS=`$ASFLAGS get_field ASFLAGS`
CFLAGS=`$CFLAGS get_field CFLAGS`
LDFLAGS=`$LDFLAGS get_field LDFLAGS`

case "$BUILD_TYPE" in
debug)
	echo_debug "Build type set to \"$BUILD_TYPE\""
	;;
release)
	echo_debug "Build_type set to \"$BUILD_TYPE\""
	CFLAGS="-O2 -DNDEBUG $CFLAGS"
	;;
*)
	fail "Build type \"$BUILD_TYPE\" is unrecognized"
	;;
esac

if [ -e $OUT_FILE ]; then
	rm $OUT_FILE
fi
touch $OUT_FILE

echo_debug "Constructing `realpath $OUT_FILE`"
echo_debug "$FIELDS"

case $MG_TYPE in
meta)
	SUBDIRS=`get_field SUBDIRS`
	SUBDIR_TARGETS=""
	for SUBDIR in $SUBDIRS; do
		SUBDIR_TARGETS="$SUBDIR_TARGETS $SUBDIR.dir"
	done
	
	write_meta
	for SUBDIR in $SUBDIRS; do
		RETURN_DIR=`echo $PWD`
		cd "$SUBDIR" && "$MAKEGEN" && cd "$RETURN_DIR"
		unset RETURN_DIR
	done
	;;
prog)
	TARGET=`get_field TARGET`
	SRCS=`get_field SRCS`
	SRCS=`echo $SRCS`
	INSTALL_DIR=`get_field INSTALL_DIR`
	LINKER=`get_field LINKER`
	if [ -z "$LINKER" ]; then
		LINKER="\$(CC)"
	fi

	echo_debug "\$TARGET has value '$TARGET'"
	echo_debug "\$SRCS has value '$SRCS'"

	OBJS=
	for SRC_FILE in $SRCS; do
		OBJS="$OBJS \$(BUILD_DIR)/`echo $SRC_FILE | tr '/' '.'`.o"
	done

	echo_debug "\$PREFIX = $PREFIX"
	if [ "{$PREFIX#${PREFIX%?}}" != / ]; then
		PREFIX="$PREFIX/"
	fi
	if [ "{$INSTALL_DIR#${INSTALL_DIR%?}}" != / ]; then
		INSTALL_DIR="$INSTALL_DIR/"
	fi

	write_prog
	;;
lib)
	LIB_TYPE=`get_field LIB_TYPE`
	case $LIB_TYPE in
	static)
		#LDFLAGS=
		;;
	shared)
		CFLAGS="$CFLAGS -fpic"
		LDFLAGS="$LDFLAGS -static"
		;;
	*)
		fail "Invalid library type $LIB_TYPE specified"
		;;
	esac
	
	TARGET=`get_field TARGET`
	SRCS=`get_field SRCS`
	SRCS=`echo $SRCS`
	INSTALL_DIR=`get_field INSTALL_DIR`
	LINKER=`get_field LINKER`
	if [ -z "$LINKER" ]; then
		LINKER="\$(CC)"
	fi
	
	OBJS=
	for SRC_FILE in $SRCS; do
		OBJS="$OBJS \$(BUILD_DIR)/`echo $SRC_FILE | tr '/' '.'`.o"
	done
	
	if [ "{$PREFIX#${PREFIX%?}}" != / ]; then
		PREFIX="$PREFIX/"
	fi
	if [ "{$INSTALL_DIR#${INSTALL_DIR%?}}" != / ]; then
		INSTALL_DIR="$INSTALL_DIR/"
	fi
	
	write_lib
	;;
*)
	fail "`realpath $IN_FILE`: Invalid TYPE field or TYPE field missing"
	;;
esac

